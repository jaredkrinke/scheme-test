(define (make-dfa states alphabet transition-function start-state accept-states)
    (define (set-contains? set item)
            (cond ((null? set) false)
                  ((eq? (car set) item) true)
                  (else (set-contains? (cdr set) item))))
    (define (accept-state? state)
            (set-contains? accept-states state))
    (define (dfa-test-iter state string)
            (if (null? string)
                (accept-state? state)
                (dfa-test-iter (transition-function state (car string))
                               (cdr string))))
    (define (test string)
        (dfa-test-iter start-state string))

    (lambda (message a b c)
            (cond ((eq? message 'test) (test a)))))

(let (
      (d (make-dfa
          '(q1 q2 q3)
          '(0 1)
          (lambda (state input)
                  (cond ((and (eq? state 'q1) (= input 0)) 'q1)
                        ((and (eq? state 'q1) (= input 1)) 'q2)
                        ((and (eq? state 'q2) (= input 0)) 'q3)
                        ((and (eq? state 'q2) (= input 1)) 'q2)
                        ((and (eq? state 'q3) (= input 0)) 'q2)
                        ((and (eq? state 'q3) (= input 1)) 'q2)
                  ))
          'q1
          '(q2)))
      )
      
      (display (d 'test '(0))) (newline)
      (display (d 'test '(1 0))) (newline)
      (display (d 'test '(1 0 0))) (newline)
      (display (d 'test '(1 0 0 0))) (newline)
      (display (d 'test '(1 0 0 0 0))) (newline)
)

